Coil is a simple and powerful configuration language for configuring a wide
range of systems. You can think of it as object oriented key-value pairs. Blocks
of configuration called "structs" in which key-value pairs are defined, can be
easily abstracted and inherited by other blocks. These pairs can be overridden or
removed, linked to other values, or used in an expression. Values can be boolean,
numbers, strings, links to other values, or lists.

The authorative implementation of Coil, which is in Python, resides at code.google.com/p/coil and is
maintained by ITA Softare where it was concieved.

This project is a port in C which aims to maximize backwards compatibility, speed, and introduce some
helpful new features and syntax along the way.

There is great documentation for the pure python impelemtation available @
http://mike.marineau.org/coil/ which includes a description of the general coil language
which applies to this project as well.

This project will also provide a python extension such that all
applications currently using the pure python implementation can
use this project with minimal boilerplate.


------------------------------------------------------------------------------
Coil Basics
------------------------------------------------------------------------------

Coil consists primarily of keys and values. Keys can contain any alphnumeric
characters as well as - and _.

Values may be:

  - None

  - True or False

  - Signed or unsigned integers such as 1, 42, or -12

  - Signed or unsigned floating point numbers such as 10.01 or -12.5

  - Literal strings delimited with " or ' and alternatively for multiline
    strings """ or '''

  - String expressions

  - List of values delimited by [ and ] ie..
    some_list: [1 2.5 'Hello' -42 True]


Whitespace between keys and values does not matter.

is_ok: True
description: "This is Coil"

is treated the same as

is_ok: True description: "This is Coil"


Groups of key value pairs can be defined inside of a "struct" which may look
like...

config-a: {
  is_ok: True
  extra: False
  description: "This is config a"
}

config-b: {
  extra: False
  is_ok: True
  description: "This is config b"
}

Structs can be abstracted to form base groups of common key-value pairs. For the
trivial example above we could rewrite as..

config-base: {
  extra: False
  is_ok: True
}

config-a: config-base {
  description: "This is config a"
}

config-b: config-base {
  description: "This is config b"
}

Multiple structs can be inherited from at the same time:

config-c: {
  another_key: "another value"
}

config-d: config-a, config-c {
  description: "This is config d"
}

Keys can be deleted to prevent inheriting the entire parent struct.

config-base-extra: config-base {
  extra: True
  ~is_ok
}

Would be equivalent to..

config-base-extra: {
  extra: True
}

Coil also has a pathing scheme which allows any value to be access with a unique
path. These paths can be relative to a struct or absolute (relative to the top
level root struct).

A relative path may be prefixed with a series of dots '.' which similarly to ..
on a command line means to traverse up the parent hierarchy.

An absolute path is prefixed with @root


Paths can also be used to define values or add values to a
struct.

a.b.c: 123

is equivalent to

a: {
  b: {
    c: 123
  }
}

To add a value to a struct:
a: {
  # a has no values :(
}
a.x: 123

yeilds
a: { x: 123 }

Such additions do not affect the consistency of inheriting structs as they
will inherit the struct exactly as it is defined when it is inherited.

a.x: 1
b: a {}
a.y: 2

Will produce..

a: { x: 1 y: 2 }
b: { x: 1 }

While..

a.x: 1
a.y: 2
b: a {}

Will produce...

a: { x:1 y:2 }
b: { x:1 y:2 }


Values can be linked together

a: 123
b: a

is the same as

a: 123
b: 123

There are a couple of cases where the path scheme can be tricky. Particularly
when using shorthand definitions such as a.b.c: =some_path. In this case
some_path is relative to a.b as it would be if you were to use the longer more
expanded notation.

a.b.c: =somepath #somepath must be in a.b

a: {
  b: {
    somepath: 123
    c: =somepath
  }
}


To illustrate the relative pathing in links consider the following..

a: {
  one: 1
  b: {
    number: ..one
  }
}

a.b.number will have the value 1

Consider another example...

one: 1
a: {
  b: {
    c: {
      number: ....one
    }
  }
}

a.b.c.number will have the value 1

------------------------------------------------------------------------------
Changes from the pure python implementation.
------------------------------------------------------------------------------

New supported list syntax:

abc: [ 1 2 3 ] # compatible
abc: [ 1, 2, 3 ] # new

New inheritence syntax:

# This is backwards compatible ...
abc: {
  @extends: ..x
  @extends: ..y
  @extends: ..z
}

# This is new...
abc: { @extends: [ ..x, ..y, ..z ] } # new
abc: { @extends: ..x, ..y, ..z }     # new
abc: x, y, z {}                      # new


Dynamic expansion and late binding. Values are now expanded only when they
are needed which allows decoupling the keys from their values until they are
accessed.

a: =b  # link to b
b: 1

is now equivalent to

b: 1
a: =b

A: { @extends: ..B } # B is defined later
B: { x: 1 y: 2 z: 3 }
